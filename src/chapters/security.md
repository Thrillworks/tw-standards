---
title: 'Security'
dateUpdated: '27-02-2021'
summary: 'About security principles'
tags: ['security', 'authentication', 'authorization', 'data', 'passwords', 'tokens']
chapter: '14'
---
# 14. Security
1. ## General Principles
	1. ### When in Doubt, Ask For Help.
		Security is hard and it is easy to make a mistake. If you find yourself in the slightest doubt about a security topic, ask for assistance or a second opinion.
	2. ### Code-Review All Security-Related Code.
		All security-related code should be reviewed. This means that such code should be written to be easy to audit. In other words, it is not enough for the code to be secure. It should also be easy to see that it is in fact secure.
	3. ### Avoid DIY Security.
		When it comes to security, do-it-yourself is rarely a good idea, since it is very hard to verify that your solution actually delivers. It’s better to go with battle-tested third-party solutions.
	4. ### Choose Third-Party Software Wisely.
		However, third-party software brings the risk of security vulnerabilities. Keep this in mind when choosing third-party software.
	5. ### Keep Third-Party Software Up To Date.
		Established solutions only offer more security if you keep up with security fixes. For this reason, keep third-party software up to date. NPM provides a security overview with each `npm install` 
	6. ###  Ensure Authentication and Authorization.
		Most apps require a method for establishing who the user is (authentication) and what they are allowed to do (authorization). You need to ensure that those methods actually work and cannot be circumvented.
	7. ### Do Not Trust the Client.
		Anything that is stored in the browser’s or app’s memory can be accessed by the user. Proceed with this assumption. When you send JavaScript to a browser, you have no way of knowing if the browser will run this code unmodified. So, any security that you implement client-side can be easily circumvented. Do not send to the browser any data the user should not see. Do not accept from a browser any requests that the user should not be able to make.
	8. ### Practice “Courtesy Security” Client-Side.
		Client-side security is “courtesy security”. It’s not there to stop the user from misbehaving – that should be done by the server. The client’s role is to guide the user towards choices that won’t lead to a disappointingly rude response from the server. E.g., disable the button that the user shouldn’t click. They can still go into the console and use it to ask the server to do something they are not allowed to do. But at that point, a 400-level response is fair game. A well-behaved user, however, should be guided away from prohibited actions. Client-side “courtesy security” frees your server from the need to be polite and simplifies your architecture.
	9. ### Secure Data in Transit.
		Data should be encrypted when travelling along channels where someone could intercept it. There are good, standard solutions for that.
	10. ### Secure Data at Rest.
		Data should be secure while it is being stored. AES or RSA encryption should be used. Always store Keys for decrypting in a separate location from the data. Ensure separate authentication and authorization between those systems.
	11. ### Secure the Keys.
		If you encrypt the data, it is only secure as long as the keys are secure. Consider how keys are being managed in your system. (See above)
	12. ### Protect Data From Yourself.
		In many cases, users’ data needs to be protected not only from outsiders or other users, but also from our own and client’s staff. Among other things, this usually means that you need to set things up in such a way that you wouldn’t have access to that data either.
	13. ### Plan to Deploy to the Cloud.
		Leveraging cloud infrastructure makes it easier to ensure security compared to running your own servers. Our preferred cloud provider is Amazon AWS. Note that we love Google and Azure as well, but prefer Amazon AWS for production deployment. Regardless of the system we deploy with it’s important to avoid making too many commitments to a specific system.
2. ## User Authentication
	1. ### Never Store Users’ Passwords. Store “Hashes” Instead.
		If for some reason you are not using a solution like Auth0 or AWS for authentication. End users’ passwords should never be stored in cleartext. There are no exceptions to this rule. Instead, store a “hash” generated by Bcrypt or another similar library. 

		**TL;DR**: Use Bcrypt to generate a “hash” of the user’s password and store this in the database. When the user submits a password for authentication, use Bcrypt to verify that submitted password matches the stored hash.The main problem with storing users’ password in cleartext is not even that this will allow someone to steal the password and perhaps login into your application. Rather, it is the fact that the user may well be using the same password for all sorts of other applications. Maybe they are using it to log into their bank. For this reason, storing users’ passwords in cleartext is never the right solution. In most cases the best solution is to use a key derivation function (KDF) to generate what is colloquially referred to as a “hash” of the password. This “hash” is stored instead of the password used for checking if the password supplied by the user is correct. A key produced by a KDF is often referred to as a “hash” because KDFs are often based on cryptographic hash functions and are conceptually similar. Hash functions such as MD5, SHA1, SHA256, etc, are often used to implement “poor man’s” KDFs. A simple hash function does not make the best KDF, however. Proper commonly-used KDFs include Bcrypt, PBKDF2-SHA256, and Scrypt. We usually use Bcrypt. Note that PBKDF2-SHA256 is based on SHA256, but it’s not the same thing as just using SHA256. When using a KDF, it’s important to use a different [salt] for every password to protect against dictionary attacks. If you were to try to implement your own KDF based on a hash function, you would need to make sure you use this salt properly. However, you shouldn’t write your own KDFs. Use a standard one, and it will handle salts for you.Bcrypt has one convenient feature that makes it easy to use well. Bcrypt can generate an appropriate salt automatically and you can tweak the strength by changing the “work factor” parameter. The salt and the chosen work factor are both stored in the resulting hash, so you don’t need to worry about storing them separately. This also makes it easy to upgrade the strength of your “hashes” later, as you can have the users do this whenever they change passwords. In rare cases you will need to be able to retrieve the original password. In those cases you will need to encrypt it and worry about how you manage the keys.
	2. ### Do Not Recover Passwords, Reset Them.
		If for some reason you are not using a solution like Auth0 or AWS for authentication. Storing a hash means that user’s original password cannot be recovered. Consider this a feature. However, offer the user a way of resetting their password if they have forgotten it. Password reset by email is a standard solution for password reset. You send the user a link with a token that allows them to set a new password. This solution should be implemented in such a way that the token can only be used once and that it would expire in a short period of time. The token should be chosen to be hard to guess, for example by a cryptographically secure random generator (for example, NodeJS’s `crypto.randomBytes()`).
	3. ### Ensure Minimum Password Quality.
		The needed strength of the password depends on the application. However, it is important to require some minimal strength. You shouldn’t allow your users to use “123456” or “password” as their password.
	4. ### Count Failed Login Attempts.
		Your server should not let the user keep trying different username and password combinations until they find a match. You should either lock them out after some time or use captcha. This needs to be done on the server. A user who is trying to brute-force a login is not going to do it using your client code. They’ll probably be using curl or something like this.Your server should respond to this by blocking the user, either permanently or for a short period of time. A short lockout (say, 5 minutes) can be fairly effective in stopping a brute force attack. You can also require captcha at this point. If you lock the user out permanently, you will need to make sure there is a way for them to reinstate their account.
	5. ### Consider “Social” Authentication.
		Authentication using Google, Facebook, Apple, etc., allows you to push some of the work onto those applications and the user has one less password to remember.
	6. ### Use Token-Based Authentication.
		Once the user is authenticated, you will need to either issue them an authentication token or a cookie. Tokens are vastly preferred. Cookies are easier to steal and are hard to use in a multi-server setup. Tokens solve both of those problems. They can also be used with a completely stateless server architecture. Our standard solution is JWT-style bearer tokens.
	7. ### Consider How You Store the Tokens.
		If you want the user to stay logged in after they close your application window, you will need to store the token somehow on the client. localStorage is a common option and is suitable for most applications, but you need to consider the specific requirements of your app. You need to remember to remove the tokens upon logout. Tokens stored in localStorage can be accessed by any JavaScript loaded from the same domain. This becomes a problem if your application is vulnerable to an XSS attack. Some applications may require a more elaborate approach to storing authentication tokens, though it’s important to remember that there is no silver bullet here. There are two routes towards securing `localStorage` further. One is to encrypt the token before storing. This step creates a hurdle for an attacker, but you now face the challenge of where to store the key. There are a few options, none of them entirely satisfying. Another approach is to take advantage of the fact that localStorage is domain specific to ensure that the token is written by a domain that we are certain is safe from XSS. In this case we need to figure out how to move the token between the domains, which can be done using an iframe and `postMessage()`.
	8. ###  Consider the Personal Information Stored in the Token. 
		When using JWT tokens, consider that the token carries a data payload that is signed but is not encrypted. If the content of that payload is sensitive, the server should be encrypting it before sending it to the client. A JWT token is encoded and looks encrypted, but it can be trivially converted into a JSON object.
	9. ### When Using Cookies, Protect Against CSRF.
		If you must use cookies, make sure your app is safe against cross-site request forgery (CSRF or XSRF). But really, just avoid cookies. CSRF is an attack in which someone causes the user’s browser to call your server using that user’s credentials. In this case, the user is someone who have authenticated with your server using your application, but the call is being made by another application on that user’s computer. This can involve making an action or getting data. Requests for JSON content are in theory protected from CSRF by the same-origin policy, but in practice this can be circumvented. The "JSON Array” vulnerability is just one of the ways this can be done. Angular provides a partial solution for this via the use of X-XSRF-TOKEN header. However, in order for this to work this needs to be supported on the server. You would also need to verify that this is actually working in your case. If implementing CSRF in Node, beware of this vulnerability in methodOverride middleware: “[Bypass Connect CSRF protection by abusing methodOverride Middleware.](https://github.com/nodesecurity/eslint-plugin-security/blob/master/docs/bypass-connect-csrf-protection-by-abusing.md)” And again, ask yourself if you really want to be using cookies.
	10. ### Pick a Sensible Session Expiration Policy.
		When you authenticated the user, they should not stay authenticated forever. The specific policy that makes most sense depends on the application. A common strategy is to set an expiration time and provide an endpoint for renewing the token. In this case, the client should keep track of whether the user is still active and renew the token prior to its expiration. For example, if the server issued a token that lasts for 1 week, the client wait for 3 days then renew the token when the user interacts with the system again.
	11. ### Require Re-Authentication For Sensitive Features.
		It is generally a good idea to ask the users to re-authenticate before accessing features that may be particularly sensitive. Among other things, the user should always be asked to re-authenticate before changing their password. If the user is resetting their password because they forgot it, they would need to use an alternative way of establishing their identity, e.g., the password reset token that was sent to them by email. This becomes particularly important when using an authentication strategy that allows the user to stay logged in indefinitely. HTTP does not provide standard vocabulary for such a re-authentication request, but this can be communicated by a simple 401, as long as the client knows how to handle it.
	12. ### Consider Multi-Factor Authentication.
		Multi-factor authentication means asking the user to identify themselves with something they have in addition to providing the password. The most common solution today is having the user enter a code that you send to their phone.
3. ## Authorization
	1. ### Do Not Confuse Authorization and Authentication.
		Just the fact that the user is authenticated (you know who they are) doesn’t mean you should do whatever they ask you to do.
	2. ### Consider Resource-Based Authorization.
		In many cases it makes sense to model authorization as a matter of certain users having special access to specific resources. E.g., we could designate some users as being “owners” of a particular resource and give them special access to this resource based on that fact.
	3. ### Consider Role-Based Authorization.
		In other cases it makes more sense to assign users to “roles” and link permissions with those roles. It’s usually hard to get away from resource-based authorization entirely, so in practice role-based authorization often ends up being used in combination with resource-based authorization.
4. ## Securing System Credentials and Keys
	1. ### Pick Good Passwords.
		Make sure to use good passwords for securing servers, databases, etc. Good passwords are random and look like this: “XRexQTMPvE4VjxnejG9qPg3U”. If you can remember it, it’s probably not a good password.
	2. ### Store Passwords in LastPass.
		You must use a secure password manager to store credentials, we use LastPass to keep track of those passwords. 
	3. ### Never Commit Credentials or Keys.
		Do not commit credentials and keys, such as database passwords, to the repository. Load them from environment variables or a key management system.If your software loads credentials from environment variables, you can load them into your environment from a bash script that you keep in a folder called “private” that is added to your .gitignore file to prevent you from committing it by accident. An alternative approach is to encrypt individual configurations, commit the encrypted values, and store the decryption key in an environment variable. The best approach is to use a proper key management system. While production credentials and keys are the most important ones to secure, it is best to avoid committing development and staging credentials as well, as a matter of establishing good habits.
	4. ### Change Compromised Passwords.
		Passwords or keys that have accidentally checked in to version control are there exposed forever. You need to immediately change all credentials that may have been compromised.
	5. ### Do Not Log Credentials and Keys.
		Do not log passwords and other credentials either to the console or to the file. Ever.
	6. ### You Shouldn’t Have the Production Credentials.
		If you know production credentials for a system and you are not a member of the operations team, something is not right.
	7. ###  Consider a Proper Key Management System.
		To truly secure the keys you would need to use a proper key management system, i.e., a software solution that will deliver the right keys to authorized parties. AWS’s Key Management Service (KMS) is one example of such a system. A proper key management system will be able to provide an audit of access to the keys.
5. ## Protecting Data in Transit
	1. ### Use Strong SSL in Production Between Server and Client.
		Use of HTTPS/SSL/TLS is essential for communication between the browser and the server and should make use of the latest version of SSL/TLS available. This does not necessarily need to be done in the server code - it can be done with an SSL proxy in production. It does need to be done, however. This is not necessarily something we need to provide, since this can be handled in production by the Dev Operations team via a HTTPS proxy or a load balancer that handles SSL termination. However, we need to ensure that the client understands this. Also, in cases where we are handling deployment, we absolutely need to enable SSL. Some applications may require an SSL connection between the server and the load balancer. BTW, SSL and TLS are basically the same thing. Strictly speaking, TLS is a newer version of SSL. In practice, people usually say SSL when they mean TLS. HTTPS is HTTP with TLS.
	2. ### Enable HTTP Strict Transport Security in Production.
		HTTP Strict Transport Security (HSTS) is a mechanism by which a server can tell the client that the client should never connect to this server without SSL. This can be done in production but we need to ensure that it’s done. This can be done by a proxy. We need to verify that client’s operations team is aware of this. In cases where we do deployment, we need to make sure this is done correctly.
	3. ### Ensure a Private Connection to the Database in Production.
		To ensure privacy of the data passing between the server and the database, either use SSL or put the two on a secure network. Better yet do both.All modern databases support SSL connections, but this requires a custom build and is not supported by all providers. When not using SSL, ensure that the traffic between the server and the database only passes through a private network. This can also be set up in production, but we need to ensure that the client’s operations teams understands this requirement.
6. ## Protecting Data at Rest
	1. ### Consider Drive Encryption.
		Many applications require encrypting data while it is being stored. The simplest way to achieve this is by using full hard-drive encryption. AWS makes it easy to encrypt EBS volumes with no performance loss, but you have to be mindful of where you store the keys.
	2. ### Consider Application-Level Encryption.
		Application level encryption means your application encrypts the data before saving it in the database. This is more work than full drive encryption, but offers more protection for your data. With good application-level encryption, someone who manages to get into your database will find encrypted data. Application-level encryption has an important downside: since your database essentially does not have access to the original data, many types of queries become hard or impossible to carry out. For this reason, application-level encryption is often applied selectively.
	3. ### Consider Public-Key Encryption.
		Classic symmetric encryption uses the same key for encrypting and decrypting the data. This makes sense where when the data is being encrypted for later consumption by the same entity. In cases where the data is being sent from one entity to another, however, public-key encryption makes more sense. E.g., if process A writes data into the database and process B read it, we can have process A write the data using process B’s public key. This eliminates the need to share the private key with staff members who are supporting process A.
	4. ### Use Standard Libraries.
		NodeJS’s crypto module should be the first place to look. The main functions to consider are `crypto.publicEncrypt()` and `crypto.privateDecrypt()`.
	5. ### Have a Plan For How to Manage Keys.
		Encryption is of little use if you don’t secure the keys. See section on key management.